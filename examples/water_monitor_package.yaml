###############################################################################
# Water Monitor Automation Package (Example)
#
# Drop this file (rename if desired) into your Home Assistant `packages/` folder
# and ensure `homeassistant: packages: !include_dir_named packages` is enabled.
#
# Zero / minimal user edits expected:
# - Adjust notification service if not `notify.mark`.
# - Optionally tweak helper default values below.
# (Former broad state_changed trigger removed; targeted triggers below are
#  efficient for typical homes. Add more explicit entity_ids only if you have
#  multiple integration instances.)
#
# This package auto-discovers Water Monitor leak detectors, valve + context,
# and session metrics. It sends actionable notifications, supports snooze,
# synthetic/test mode handling, valve reminders, high-usage alerts, and
# upstream health degradation notices.
###############################################################################

#############################
# Helpers (user adjustable) #
#############################
input_boolean:
  water_monitor_notifications_enabled:
    name: Water Monitor Notifications Enabled
    icon: mdi:bell
    initial: true
  water_monitor_test_mode:
    name: Water Monitor Test Mode
    icon: mdi:flask
    initial: false

input_number:
  water_monitor_large_session_volume:
    name: Water Monitor Large Session Volume (gal)
    min: 1
    max: 1000
    step: 1
    mode: box
    initial: 25
  water_monitor_valve_reminder_interval:
    name: Water Monitor Valve Reminder Interval (min)
    min: 1
    max: 180
    step: 1
    mode: box
    initial: 10
  water_monitor_snooze_minutes:
    name: Water Monitor Snooze Minutes
    min: 5
    max: 240
    step: 5
    mode: box
    initial: 30

input_datetime:
  water_monitor_snooze_until:
    name: Water Monitor Snooze Until
    has_date: true
    has_time: true
  water_monitor_last_leak_reminder:
    has_date: true
    has_time: true

###############################
# Template Sensors (optional) #
###############################
sensor:
  - platform: template
    sensors:
      water_monitor_any_leak_active:
        friendly_name: Water Monitor Any Leak Active
        unique_id: water_monitor_any_leak_active
        value_template: >
          {% set leaks = states.binary_sensor | selectattr('state','eq','on')
              | selectattr('attributes.device_class','defined')
              | selectattr('attributes.device_class','eq','problem')
              | selectattr('entity_id','search','_low_flow_leak|_tank_refill_leak|_intelligent_leak') | list %}
          {{ 'on' if leaks|length > 0 else 'off' }}
        attribute_templates:
          active_leaks: >
            {% set leaks = states.binary_sensor | selectattr('state','eq','on')
                | selectattr('attributes.device_class','defined')
                | selectattr('attributes.device_class','eq','problem')
                | selectattr('entity_id','search','_low_flow_leak|_tank_refill_leak|_intelligent_leak') | list %}
            {{ leaks | map(attribute='entity_id') | list }}


#############################################
# Core Automation: Water Monitor Orchestrator
#
# Option B (targeted triggers): Replaces the prior broad state_changed event
# trigger. Focused state triggers (wildcards) for Water Monitor entities,
# plus explicit valve + periodic tick + mobile actions, cut invocation
# frequency massively (only on relevant entity changes) while still
# dynamically discovering new leak/health/session sensors via globs.
#
# Edit points (search for EDIT ME):
#   1. valve_entity variable (if you have a shutoff valve)
#   2. notify_service if not notify.mark
# If you have multiple valves, add additional valve entity IDs to the
# valve state trigger block.
#############################################
automation:
  - id: water_monitor_orchestrator
    alias: Water Monitor Orchestrator
    mode: restart
    description: Unified leak, valve, high usage, reminders, and upstream health notifications.
    variables:
      # Auto-discover valve entity from leak detector attributes (no manual config needed)
      valve_entity: >
        {% set leak_sensors = states.binary_sensor 
           | selectattr('entity_id', 'match', '.*_(low_flow_leak|tank_refill_leak|intelligent_leak)$') 
           | list %}
        {% for sensor in leak_sensors %}
          {% set valve_attr = sensor.attributes.get('auto_shutoff_valve_entity') %}
          {% if valve_attr %}{{ valve_attr }}{% break %}{% endif %}
        {% endfor %}
      notify_service: notify.mark  # EDIT ME if different
      # NOTE: Home Assistant does NOT allow templating the trigger entity_id list.
      # That means we cannot define leak/upstream/volume entity lists here and
      # reference them in the triggers below via {{ variables }}. If you need to
      # change which entities are used, edit the static entity_id lists inside
      # the trigger section directly. For multi‑instance setups, duplicate the
      # relevant trigger block and add the extra entity IDs.
      # If you want a fully parameterized version, convert this into a Blueprint
      # with inputs for leak sensors, upstream sensor(s), session sensors, and
      # valve. (Happy to generate that — just ask.)
      #
      # notify_service above is used throughout with action: "{{ notify_service }}".
      # Replace it with your mobile app notify.* or group notify target.
      # Derived (no edit needed)
      valve_state_entity: "{{ valve_entity if valve_entity != '' else 'input_boolean.water_monitor_notifications_enabled' }}"
      now_ts: "{{ now().timestamp() }}"
      snooze_until: >
        {% set dt = states('input_datetime.water_monitor_snooze_until') %}
        {% if dt in ('unknown','unavailable','') %}0{% else %}{{ as_timestamp(strptime(dt, '%Y-%m-%d %H:%M:%S')) }}{% endif %}
      snoozed: "{{ now().timestamp() < snooze_until }}"
      large_threshold: "{{ states('input_number.water_monitor_large_session_volume') | float(25) }}"
      reminder_interval_min: "{{ states('input_number.water_monitor_valve_reminder_interval') | int(10) }}"
      snooze_minutes: "{{ states('input_number.water_monitor_snooze_minutes') | int(30) }}"
      last_reminder_ts: >
        {% set dt = states('input_datetime.water_monitor_last_leak_reminder') %}
        {% if dt in ('unknown','unavailable','') %}0{% else %}{{ as_timestamp(strptime(dt, '%Y-%m-%d %H:%M:%S')) }}{% endif %}
      any_leak_sensor_on: "{{ is_state('sensor.water_monitor_any_leak_active','on') }}"
      synthetic_mode: "{{ is_state('sensor.water_monitor_synthetic_active','on') }}"
      trigger_is_state_change: "{{ trigger.platform == 'state' }}"
      trigger_entity: >
        {{ trigger.entity_id if trigger_is_state_change else '' }}
      old_state: >
        {{ trigger.from_state.state if trigger_is_state_change and trigger.from_state is not none else '' }}
      new_state: >
        {{ trigger.to_state.state if trigger_is_state_change and trigger.to_state is not none else '' }}
      is_leak_entity: >
        {{ trigger_entity is match('binary_sensor\\..*_(low_flow_leak|tank_refill_leak|intelligent_leak)$') }}
      is_upstream_entity: >
        {{ trigger_entity is match('binary_sensor\\..*_upstream_health$') }}
      is_last_session_entity: >
        {{ trigger_entity is match('sensor\\..*_last_session_volume$') }}
      leak_turning_on: >
        {{ trigger.id == 'leak_on' }}
      leak_turning_off: >
        {{ trigger.id == 'leak_off' }}
      upstream_down: >
        {{ is_upstream_entity and old_state in ['on'] and new_state == 'off' }}
      upstream_up: >
        {{ is_upstream_entity and old_state in ['off'] and new_state == 'on' }}
      last_session_volume: >
        {% if is_last_session_entity %}{{ trigger.to_state.state | float(0) }}{% else %}0{% endif %}
      high_session: >
        {{ trigger.id == 'current_session_high' }}
      leak_auto_shutoff_effective: >
        {% if leak_turning_on or leak_turning_off %}
          {{ trigger.to_state.attributes.get('auto_shutoff_effective', False) }}
        {% else %}False{% endif %}
      leak_valve_entity: >
        {% if leak_turning_on or leak_turning_off %}
          {{ trigger.to_state.attributes.get('auto_shutoff_valve_entity') or valve_state_entity or '' }}
        {% else %}{{ valve_state_entity or '' }}{% endif %}
      leak_valve_off: >
        {% if leak_turning_on or leak_turning_off %}
          {{ trigger.to_state.attributes.get('valve_off', False) }}
        {% else %}False{% endif %}
      leak_type: >
        {% if is_leak_entity %}{% if trigger_entity.endswith('_low_flow_leak') %}Low Flow{% elif trigger_entity.endswith('_tank_refill_leak') %}Tank Refill{% elif trigger_entity.endswith('_intelligent_leak') %}Intelligent{% else %}Leak{% endif %}{% else %}''{% endif %}
      valve_closed_event: >
        {{ valve_state_entity != '' and trigger_entity == valve_state_entity and old_state in ['on','open'] and new_state in ['off','closed'] }}
      reminder_due: >
        {{ any_leak_sensor_on and (now().timestamp() - last_reminder_ts) / 60 >= (reminder_interval_min | int) and not snoozed }}
      _actionable_actions: >
        {% set show_actions = not synthetic_mode %}
        {% set base = [
         {'action':'WATER_SNOOZE','title':'Snooze'}
         ] if show_actions and (leak_turning_on or reminder_due) else [] %}
        {% set reopen = [{'action':'WATER_REOPEN','title':'Reopen Water'}]
          if show_actions and leak_auto_shutoff_effective and leak_valve_off and (leak_turning_on or reminder_due) else [] %}
        {% set shutoff = [{'action':'WATER_SHUTOFF','title':'Shut Off Water'}]
          if show_actions and leak_turning_on and (not leak_auto_shutoff_effective) and leak_valve_entity else [] %}
        {% set test_toggle = [
          {'action':'WATER_UNMARK_TEST','title':'Mark Real'} if is_state('input_boolean.water_monitor_test_mode','on') else {'action':'WATER_MARK_TEST','title':'Mark Test'}
          ] if synthetic_mode else [] %}
        {{ base + reopen + shutoff + test_toggle }}
    trigger:
      # Leak state transitions only (ignore attribute churn):
      - platform: state
        id: leak_on
        from: 'off'
        to: 'on'
        entity_id:
          - binary_sensor.water_monitor_synth_low_flow_leak          # comment out if not created
          - binary_sensor.water_monitor_synth_tank_refill_leak       # optional
          - binary_sensor.water_monitor_synth_intelligent_leak       # optional / experimental
      - platform: state
        id: leak_off
        from: 'on'
        to: 'off'
        entity_id:
          - binary_sensor.water_monitor_synth_low_flow_leak          # comment out if not created
          - binary_sensor.water_monitor_synth_tank_refill_leak       # optional
          - binary_sensor.water_monitor_synth_intelligent_leak       # optional / experimental
      - platform: state
        id: upstream
        entity_id:
          - binary_sensor.water_monitor_synth_upstream_health
  # (Removed obsolete state-based current_session_high trigger referencing missing entity)
      # High session trigger using template (fires once when threshold sustained 5s)
      - platform: template
        id: current_session_high
        value_template: >-
          {% set cur = state_attr('sensor.water_monitor_last_session_volume','current_session_volume') | float(0) %}
          {% set threshold = states('input_number.water_monitor_large_session_volume') | float(25) %}
          {{ cur >= threshold }}
        for:
          seconds: 5
      - platform: state
        id: valve
        entity_id: input_boolean.water_monitor_notifications_enabled  # dummy valve fallback; replace with your valve entity if set
      - platform: time_pattern
        id: tick
        minutes: "/1"
      - platform: event
        id: mobile_action
        event_type: mobile_app_notification_action
    condition: []
    action:
      # Diagnostic logging to identify which trigger fires frequently.
      - variables:
          dbg_trigger_id: "{{ trigger.id if trigger is defined else 'none' }}"
          dbg_entity: "{{ trigger.entity_id if trigger.platform == 'state' else '' }}"
      - service: system_log.write
        data:
          message: "water_monitor_orchestrator fired id={{ dbg_trigger_id }} entity={{ dbg_entity }}"
          level: info
      - choose:
          - conditions: >
              {{ trigger.platform == 'event' and trigger.event.event_type == 'mobile_app_notification_action' }}
            sequence:
              - variables:
                  mobile_action: "{{ trigger.event.data.action }}"
              - choose:
                  - conditions: "{{ mobile_action == 'WATER_SNOOZE' }}"
                    sequence:
                      - service: input_datetime.set_datetime
                        data:
                          entity_id: input_datetime.water_monitor_snooze_until
                          datetime: "{{ (now() + timedelta(minutes=snooze_minutes|int)).strftime('%Y-%m-%d %H:%M:%S') }}"
                      - action: "{{ notify_service }}"
                        data:
                          message: "Water alerts snoozed for {{ snooze_minutes }} minutes."
                  - conditions: "{{ mobile_action == 'WATER_REOPEN' and states(leak_valve_entity) in ['off','closed'] }}"
                    sequence:
                      - service: homeassistant.turn_on
                        target:
                          entity_id: "{{ leak_valve_entity }}"
                      - action: "{{ notify_service }}"
                        data:
                          message: "Reopening water ({{ leak_valve_entity }}) requested."
                  - conditions: "{{ mobile_action == 'WATER_SHUTOFF' and leak_valve_entity != '' and states(leak_valve_entity) in ['on','open'] }}"
                    sequence:
                      - service: homeassistant.turn_off
                        target:
                          entity_id: "{{ leak_valve_entity }}"
                      - action: "{{ notify_service }}"
                        data:
                          message: "Shutting off water ({{ leak_valve_entity }}) requested."
                  - conditions: "{{ mobile_action == 'WATER_MARK_TEST' }}"
                    sequence:
                      - service: input_boolean.turn_on
                        target:
                          entity_id: input_boolean.water_monitor_test_mode
                  - conditions: "{{ mobile_action == 'WATER_UNMARK_TEST' }}"
                    sequence:
                      - service: input_boolean.turn_off
                        target:
                          entity_id: input_boolean.water_monitor_test_mode
              - stop: "Handled mobile action"
          - conditions: "{{ leak_turning_on }}"
            sequence:
              - condition: state
                entity_id: input_boolean.water_monitor_notifications_enabled
                state: 'on'
              - variables:
                  notif_tag: "water_monitor_{{ trigger.entity_id | replace('.','_') }}"
                  leak_name: >
                    {% if trigger.entity_id.endswith('_low_flow_leak') %}Low Flow
                    {% elif trigger.entity_id.endswith('_tank_refill_leak') %}Tank Refill
                    {% elif trigger.entity_id.endswith('_intelligent_leak') %}Intelligent
                    {% else %}Leak{% endif %}
                  is_synthetic: "{{ (trigger.to_state.attributes.get('synthetic_flow_at_trigger', 0) | float(0)) > 0 }}"
                  valve_effective: "{{ trigger.to_state.attributes.get('auto_shutoff_effective', False) }}"
                  valve_is_off: "{{ trigger.to_state.attributes.get('valve_off', False) }}"
                  valve_entity_ref: "{{ trigger.to_state.attributes.get('auto_shutoff_valve_entity') or valve_entity or '' }}"
                  # Build dynamic action list
                  actions_list: >
                    {% set actions = [] %}
                    {% if not is_synthetic %}
                      {% set actions = actions + [{'action': 'WATER_SNOOZE', 'title': 'Snooze'}] %}
                    {% endif %}
                    {% if valve_effective and valve_is_off %}
                      {% set actions = actions + [{'action': 'WATER_REOPEN', 'title': 'Reopen Water'}] %}
                    {% endif %}
                    {% if not valve_effective and valve_entity_ref %}
                      {% set actions = actions + [{'action': 'WATER_SHUTOFF', 'title': 'Shut Off Water'}] %}
                    {% endif %}
                    {% if is_state('input_boolean.water_monitor_test_mode', 'on') %}
                      {% set actions = actions + [{'action': 'WATER_UNMARK_TEST', 'title': 'Mark Real'}] %}
                    {% else %}
                      {% set actions = actions + [{'action': 'WATER_MARK_TEST', 'title': 'Mark Test'}] %}
                    {% endif %}
                    {{ actions }}
              - action: "{{ notify_service }}"
                data:
                  title: >
                    {% if is_synthetic %}TEST Leak ({{ leak_name }}){% else %}Water Leak Detected ({{ leak_name }}){% endif %}
                  message: >
                    {% set trigger_time = as_timestamp(trigger.to_state.last_changed) | timestamp_custom('%-m/%-d %-I:%M %p') %}
                    {% if is_synthetic %}🧪 Simulation mode active. {% endif %}
                    {% if trigger.entity_id.endswith('_low_flow_leak') %}
                      🚰 {{ leak_name }} Leak • {{ trigger_time }}
                      {% set flow_rate = trigger.to_state.attributes.get('flow', 0) | round(2) %}
                      {% set duration = trigger.to_state.attributes.get('count_progress_s', 0) | round(0) %}
                      Persistent {{ flow_rate }} GPM flow for {{ duration }}s
                      {% if valve_effective %}{% if valve_is_off %}Valve is OFF.{% else %}Valve shutting off...{% endif %}{% else %}{% if valve_entity_ref %}Check faucets, toilets, outdoor taps{% endif %}{% endif %}
                    {% elif trigger.entity_id.endswith('_tank_refill_leak') %}
                      🚽 {{ leak_name }} Leak • {{ trigger_time }}
                      {% set similar_count = trigger.to_state.attributes.get('similar_count', 0) %}
                      {% set window_min = (trigger.to_state.attributes.get('window_s', 0) / 60) | round(0) %}
                      {% set events = trigger.to_state.attributes.get('contributing_events', []) %}
                      {{ similar_count }} similar bursts in {{ window_min }} minutes:
                      {% for event in events[:4] -%}
                      • {{ event.local_time or 'unknown' }}: {{ (event.volume | float) | round(2) }} gal, {{ event.duration_s }}s{% if not loop.last %}  {% endif %}
                      {%- endfor %}
                      {% if events | length > 4 %}(+{{ events | length - 4 }} more){% endif %}
                      {% if valve_effective %}{% if valve_is_off %}Valve is OFF.{% else %}Valve shutting off...{% endif %}{% endif %}
                    {% elif trigger.entity_id.endswith('_intelligent_leak') %}
                      🧠 {{ leak_name }} Leak • {{ trigger_time }}
                      {% set current_usage = trigger.to_state.attributes.get('current_usage', 0) | round(1) %}
                      {% set baseline = trigger.to_state.attributes.get('baseline_usage', 0) | round(1) %}
                      Unusual pattern: {{ current_usage }} gal (baseline: {{ baseline }} gal)
                      {% set context = trigger.to_state.attributes.get('usage_context', 'Unknown context') %}
                      Context: {{ context }}
                      {% if valve_effective %}{% if valve_is_off %}Valve is OFF.{% else %}Valve shutting off...{% endif %}{% endif %}
                    {% else %}
                      {{ leak_name }} leak detected by {{ state_attr(trigger.entity_id,'friendly_name') }}.
                      {% if valve_effective %}{% if valve_is_off %}Valve is OFF.{% else %}Valve shutting off...{% endif %}{% else %}{% if valve_entity_ref %}Valve still ON.{% endif %}{% endif %}
                    {% endif %}
                  data:
                    tag: "{{ notif_tag }}"
                    actions: "{{ actions_list }}"
          - conditions: "{{ leak_turning_off }}"
            sequence:
              - condition: state
                entity_id: input_boolean.water_monitor_notifications_enabled
                state: 'on'
              - action: "{{ notify_service }}"
                data:
                  title: "Leak Cleared ({{ leak_type }})"
                  message: >
                    {% set clear_time = as_timestamp(trigger.to_state.last_changed) | timestamp_custom('%-m/%-d %-I:%M %p') %}
                    {% if trigger.entity_id.endswith('_low_flow_leak') %}
                      ✅ {{ leak_type }} Cleared • {{ clear_time }}
                      Flow returned to normal
                    {% elif trigger.entity_id.endswith('_tank_refill_leak') %}
                      ✅ {{ leak_type }} Cleared • {{ clear_time }}
                      {% set timeout_min = (trigger.to_state.attributes.get('timeout_cleared_s', 0) / 60) | round(0) %}
                      No similar patterns for {{ timeout_min }} minutes
                      {% set last_event = trigger.to_state.attributes.get('contributing_events', []) | last %}
                      {% if last_event %}Last: {{ (last_event.volume | float) | round(2) }} gal, {{ last_event.duration_s }}s at {{ last_event.local_time }}{% endif %}
                    {% elif trigger.entity_id.endswith('_intelligent_leak') %}
                      ✅ {{ leak_type }} Cleared • {{ clear_time }}
                      Usage pattern returned to normal
                      {% set current_usage = trigger.to_state.attributes.get('current_usage', 0) | round(1) %}
                      Current: {{ current_usage }} gal
                    {% else %}
                      ✅ {{ leak_type }} cleared • {{ clear_time }}
                    {% endif %}
              - service: input_datetime.set_datetime
                data:
                  entity_id: input_datetime.water_monitor_last_leak_reminder
                  datetime: "1970-01-01 00:00:00"
              - service: input_datetime.set_datetime
                data:
                  entity_id: input_datetime.water_monitor_snooze_until
                  datetime: "1970-01-01 00:00:00"
          - conditions: "{{ upstream_down }}"
            sequence:
              - condition: state
                entity_id: input_boolean.water_monitor_notifications_enabled
                state: 'on'
              - action: "{{ notify_service }}"
                data:
                  title: Water Monitor Upstream Issue
                  message: >
                    Upstream sensors degraded: {{ trigger_entity }}. Leak monitoring may be impaired.
          - conditions: "{{ upstream_up }}"
            sequence:
              - condition: state
                entity_id: input_boolean.water_monitor_notifications_enabled
                state: 'on'
              - action: "{{ notify_service }}"
                data:
                  title: Water Monitor Upstream Restored
                  message: >
                    Upstream sensors restored: {{ trigger_entity }}.
          - conditions: "{{ high_session }}"
            sequence:
              - condition: state
                entity_id: input_boolean.water_monitor_notifications_enabled
                state: 'on'
              - variables:
                  session_entity: sensor.water_monitor_last_session_volume
                  unit: >
                    {{ state_attr(session_entity,'volume_unit') or 'units' }}
                  cur_vol: "{{ state_attr(session_entity,'current_session_volume') | float(0) | round(2) }}"
                  cur_dur: "{{ state_attr(session_entity,'current_session_duration') | int(0) }}"
                  cur_avg: "{{ state_attr(session_entity,'current_session_average_flow') | float(0) | round(2) }}"
                  high_usage_actions: >
                    {{ [{'action': 'WATER_SNOOZE', 'title': 'Snooze'}] }}
              - action: "{{ notify_service }}"
                data:
                  title: "High Water Usage ({{ cur_vol }} {{ unit }})"
                  message: >
                    Current session now at {{ cur_vol }} {{ unit }} over {{ cur_dur }}s (avg {{ cur_avg }} {{ unit }}/min). Threshold crossed.
                  data:
                    actions: "{{ high_usage_actions }}"
          - conditions: >
              {{ valve_closed_event and not leak_turning_on }}
            sequence:
              - condition: state
                entity_id: input_boolean.water_monitor_notifications_enabled
                state: 'on'
              - action: "{{ notify_service }}"
                data:
                  title: Water Valve Closed
                  message: >
                    Valve {{ leak_valve_entity }} closed.
          - conditions: >
              {{ trigger.platform == 'time_pattern' and reminder_due and not synthetic_mode }}
            sequence:
              - condition: state
                entity_id: input_boolean.water_monitor_notifications_enabled
                state: 'on'
              - variables:
                  notif_tag: water_monitor_reminder
                  elapsed_min: >
                    {% set base = last_reminder_ts if last_reminder_ts > 0 else ( now().timestamp() - (reminder_interval_min|int)*60 ) %}
                    {{ ((now().timestamp() - base)/60) | round(1) }}
                  # Reminder actions: snooze and reopen if valve available
                  reminder_actions: >
                    {% set actions = [{'action': 'WATER_SNOOZE', 'title': 'Snooze'}] %}
                    {% if valve_state_entity and states(valve_state_entity) in ['off','closed'] %}
                      {% set actions = actions + [{'action': 'WATER_REOPEN', 'title': 'Reopen Water'}] %}
                    {% endif %}
                    {{ actions }}
              - action: "{{ notify_service }}"
                data:
                  title: Leak Persists (Valve Off)
                  message: >
                    Leak still active. Valve isolated. Elapsed ~{{ elapsed_min }} min.
                  data:
                    tag: "{{ notif_tag }}"
                    actions: "{{ reminder_actions }}"
              - service: input_datetime.set_datetime
                data:
                  entity_id: input_datetime.water_monitor_last_leak_reminder
                  datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}"
        default: []
      - stop: Done

###############################################################################
# End of package
###############################################################################
